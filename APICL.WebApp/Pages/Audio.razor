@page "/audio"

@using APICL.Client
@using APICL.Shared
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@using Radzen
@using Radzen.Blazor

@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager
@inject ApiClient ApiClient
@inject ApiUrlConfig ApiConfig

<!-- Title -->
<h1 style="font-family: 'Arial Black'">APICL WebApp -- Audio<br></h1>

<!-- Waveform visualizer section: Narrow image -->
<RadzenStack Orientation="Orientation.Horizontal" AlignItems="AlignItems.Center" JustifyContent="JustifyContent.Center" Gap="0.1rem" class="rz-p-sm-12" Reverse="false">

</RadzenStack>

<!-- Audio selection section: DropDown with audio names + upload button + download button + remove button -->
<RadzenStack Orientation="Orientation.Horizontal" AlignItems="AlignItems.Center" JustifyContent="JustifyContent.Center" Gap="0.1rem" class="rz-p-sm-12" Reverse="false">
    <RadzenListBox TValue="Guid" Data="@audioInfos" TextProperty="Entry" ValueProperty="Guid"
                   @bind-Value="@selectedAudioGuid" Multiple="false" Change="@(args => LoadWaveform(args as Guid?))"
                   Style="width: 100%; max-width: 600px; height: 200px;" Name="ListBoxAudioObjects" Placeholder="-- Select Audio Object --">
    </RadzenListBox>
    <RadzenStack Orientation="Orientation.Vertical" AlignItems="AlignItems.Center" JustifyContent="JustifyContent.Center" Gap="0.1rem" class="rz-p-sm-12" Reverse="false">
        <RadzenButton Name="ButtonUploadAudio" Style="width: 120px; font-family: Arial; background-color: #e0e0e0" Text="Upload Audio" ButtonType="Radzen.ButtonType.Button" ButtonStyle="Radzen.ButtonStyle.Light" Size="Radzen.ButtonSize.Medium" Variant="Radzen.Variant.Filled">
            <InputFile id="audioUpload" OnChange="OnAudioUpload" accept="audio/*" class="rz-mb-2" />
        </RadzenButton>
        <RadzenButton Name="ButtonDownloadSelectedAudio" Style="width: 120px; font-family: Arial; background-color: #e0e0e0" Text="Download Selected Audio" ButtonType="Radzen.ButtonType.Button" ButtonStyle="Radzen.ButtonStyle.Light" Size="Radzen.ButtonSize.Medium" Variant="Radzen.Variant.Filled"
                      Click="@OnDownloadSelected"></RadzenButton>
        <RadzenButton Name="ButtonRemoveAudioObj" Style="width: 120px; font-family: Arial; background-color: #e0e0e0" Text="Remove Selected Audio" ButtonType="Radzen.ButtonType.Button" ButtonStyle="Radzen.ButtonStyle.Light" Size="Radzen.ButtonSize.Medium"
                      Variant="Radzen.Variant.Filled"
                      Click="@OnRemoveAudioObj"></RadzenButton>
    </RadzenStack>
</RadzenStack>


<!-- Timestretch section: DropDown with kernel names + execute button + input elements for arguments -->
<RadzenStack Orientation="Orientation.Horizontal" AlignItems="AlignItems.Center" JustifyContent="JustifyContent.Center" Gap="0.1rem" class="rz-p-sm-12" Reverse="false">
    <RadzenDropDown Data="@kernelInfos" TextProperty="FunctionName" ValueProperty="FunctionName" @bind-Value="@selectedKernelName"
                    AllowClear="false" AllowFiltering="false" Style="width: 25%" Name="DropDownKernels" Placeholder="-- Select Kernel --" FilterAsYouType="false" AllowSelectAll="false"></RadzenDropDown>
    <RadzenButton Name="ButtonTimestretch" Style="width: 120px; font-family: Arial; background-color: #e0e0e0" Text="Timestretch" ButtonType="Radzen.ButtonType.Submit" ButtonStyle="Radzen.ButtonStyle.Light" Size="Radzen.ButtonSize.Medium" Variant="Radzen.Variant.Filled" Disabled="false"></RadzenButton>
    <RadzenNumeric Name="NumericStretchFactor" Value="@stretchFactor" Style="width: 15%;" Placeholder="Stretch Factor" Step="0.01"></RadzenNumeric>
    <RadzenNumeric Name="NumericInitialBpm" Value="@(selectedAudioInfo?.Bpm ?? 0.0)" Style="width: 15%" Disabled="true" Placeholder="Initial BPM"></RadzenNumeric>
    <RadzenNumeric Name="NumericFinalBpm" TValue="float" bind-Value="@targetBpm" Style="width: 15%" Placeholder="Final BPM"></RadzenNumeric>
    <RadzenNumeric Name="NumericChunkSize" @bind-Value="@chunkSize" Style="width: 15%;" Placeholder="Chunk Size" Min="1024" Max="65536" Step="1024"></RadzenNumeric>
    <RadzenNumeric Name="NumericOverlap" @bind-Value="@overlap" Style="width: 15%;" Placeholder="Overlap" Step="0.01"></RadzenNumeric>
    <RadzenCheckBox Name="CheckBoxAllowScopedSession" @bind-Value="@allowScopedSession" Text="Allow Scoped Session" Style="width: 20%;"></RadzenCheckBox>

</RadzenStack>




<!-- Scrolling log list -->
<div id="logContainer" @ref="logContainer" style="height: 300px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px; background-color: #f9f9f9;">
    @foreach (var logEntry in logEntries)
    {
        <div>@logEntry</div>
    }
</div>

@code {

    private IEnumerable<AudioObjInfo> audioInfos = [];

    private string waveformBase64 = string.Empty;

    private Guid selectedAudioGuid = Guid.Empty;
    private AudioObjInfo? selectedAudioInfo => audioInfos.FirstOrDefault(info => info.Guid == selectedAudioGuid);

    private IEnumerable<OpenClKernelInfo> kernelInfos = [];
    private string selectedKernelName = string.Empty;

    private float targetBpm = 120.0f;
    private double stretchFactor => selectedAudioInfo != null && selectedAudioInfo.Bpm > 0 ? targetBpm / selectedAudioInfo.Bpm : 1.0f;
    private int chunkSize = 16384;
    private float overlap = 0.5f;

    private bool allowScopedSession = true;


    private List<string> logEntries = [];
    private ElementReference logContainer;

    private void AddLogEntry(string message)
    {
        logEntries.Add($"{DateTime.Now:HH:mm:ss:fff} - {message}");
        if (logEntries.Count > 100)
        {
            logEntries.RemoveAt(0);
        }

        StateHasChanged();
    }

    protected override async Task OnInitializedAsync()
    {
        AddLogEntry("Initializing Audio page...");
        await RefreshInfos();
    }

    protected async Task RefreshInfos()
    {
        // Get audio infos
        kernelInfos = await ApiClient.GetOpenClKernelInfos("stretch");

        AddLogEntry($"Refreshed infos.");

        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (logEntries.Any())
        {
            await JSRuntime.InvokeVoidAsync("eval", $@"
                var el = document.getElementById('logContainer');
                if (el) {{
                    el.scrollTop = el.scrollHeight;
                }}
            ");
        }
    }

    private async Task ExecuteTimestretch()
    {
        var result = await ApiClient.ExecuteTimestretch(
            selectedAudioGuid,
            selectedKernelName, "",
            stretchFactor, chunkSize, overlap,
            false, allowScopedSession
        );

        await RefreshInfos();
    }

    private async Task LoadWaveform(Guid? guid = null)
    {
        guid ??= selectedAudioGuid;
        waveformBase64 = string.Empty;
        if (guid == Guid.Empty)
        {
            AddLogEntry("Guid was empty, cleared audio data.");
            return;
        }
        var obj = audioInfos.FirstOrDefault(i => i.Guid == guid.Value);
        if (obj == null)
        {
            AddLogEntry($"No audio found for Guid '{guid.Value}'");
            return;
        }
        try
        {
            var data = await ApiClient.GetBase64Waveform(guid.Value);
            waveformBase64 = $"data:image/png;base64,{data.WaveformBase64}";
            AddLogEntry($"Retrieved base64 string from '{guid.Value}' (length: {data.WaveformBase64.Length})");
        }
        catch (Exception ex)
        {
            waveformBase64 = string.Empty;
            AddLogEntry($"Error getting base64 string for waveform ''{guid.Value}': " + ex);
        }
        finally
        {
            StateHasChanged();
        }
    }

    protected async Task OnAudioUpload(InputFileChangeEventArgs e)
    {
        try
        {
            var file = e.File;
            if (file.Size > 0)
            {
                await using var stream = file.OpenReadStream(maxAllowedSize: 512 * 1024 * 1024); // Max 512 MB
                FileParameter fp = new FileParameter(stream, file.Name, file.ContentType);
                var info = await ApiClient.UploadAudio(fp);
                AddLogEntry($"Uploaded '{info.Name}' successfully.");
                await RefreshInfos();
            }
        }
        catch (Exception ex)
        {
            AddLogEntry($"Error uploading audio: {ex.Message}");
        }
    }

    protected async Task OnDownloadSelected()
    {
        Guid? guidToDownload = null;
        string fileName = "";

        if (selectedAudioInfo != null)
        {
            if (selectedAudioInfo.Guid != Guid.Empty)
            {
                guidToDownload = selectedAudioInfo.Guid;
                fileName = selectedAudioInfo.Name;
            }
        }

        if (guidToDownload.HasValue)
        {
            AddLogEntry($"Downloading track with Guid: {guidToDownload.Value}...");
            try
            {
                // Direkt die URL zum API-Endpunkt aufrufen
                string downloadUrl = $"{ApiConfig.BaseUrl}/api/audio/download/{guidToDownload.Value}";

                // Rufe die JavaScript-Funktion auf, um den Download zu starten
                await JSRuntime.InvokeVoidAsync("downloadFileFromUrl", downloadUrl, $"{fileName}.wav");

                // Füge diese Zeile hinzu:
                AddLogEntry($"Got Download-URL: {downloadUrl}");

                AddLogEntry($"Downloading '{fileName}' started.");
            }
            catch (Exception ex)
            {
                AddLogEntry($"Error downloading '{fileName}': {ex.Message}");
            }
        }
        else
        {
            AddLogEntry("No audio selected to download.");
        }

        StateHasChanged();
    }

    private async Task OnRemoveAudioObj()
    {
        if (selectedAudioGuid == Guid.Empty)
        {
            AddLogEntry("No audio selected to remove.");
            return;
        }

        var result = await ApiClient.RemoveAudio(selectedAudioGuid);

        if (result == true)
        {
            AddLogEntry($"Track with Guid {selectedAudioGuid} removed successfully.");
            await RefreshInfos();
        }
        else
        {
            AddLogEntry($"Failed to remove track with Guid {selectedAudioGuid}.");
        }

        selectedAudioGuid = Guid.Empty;

        StateHasChanged();
    }

}
